/**
 * Copyright Â© Magento, Inc. All rights reserved.
 * See COPYING.txt for license details.
 */

import { join } from 'path';
import { Logger } from './logger';
import { Config } from './configLocator';
// TODO: Switch from promisify to fs promises when not experimental in node
import { promisify as p } from 'util';
import { readFile, writeFile, mkdir } from 'fs';
import { computeBundles } from './computeBundles';
import { getAllLanguages } from './magentoFS';
import { createResolver, Resolver } from './resolver';
import {
    wrapTextModule,
    wrapNonShimmedModule,
    isAMDWithDefine,
    isNamedAMD,
    wrapShimmedModule as wrapShimmedModuleTemp,
} from './transformation';
import MagicString, { Bundle as MagicBundle } from 'magic-string';

type Opts = {
    config: Config;
    bundleSpec: ReturnType<typeof computeBundles>;
    requireConfig: RequireConfig;
    logger: Logger;
};
export async function createBundles(opts: Opts) {
    const { theme, staticFolderPath, outDir } = opts.config;
    const { bundleSpec } = opts;

    const langs = await getAllLanguages(staticFolderPath, theme);
    opts.logger.log(
        `Found ${langs.length} languages for theme ${theme.name}: ${langs.join(
            ', ',
        )}`,
    );

    // TODO: Do we actually need to handle multilang for JS?
    // If so, should probably do it :)
    const firstLang = langs[0];
    const baseDir = join(
        staticFolderPath,
        'frontend',
        theme.vendor,
        theme.name,
        firstLang,
    );

    const resolve = createResolver(opts.requireConfig, baseDir);
    opts.logger.log(`Created RequireJS resolver with baseDir: ${baseDir}`);

    await p(mkdir)(outDir, { recursive: true });

    for (const [name, group] of bundleSpec) {
        const bundle = await generateBundleFile(
            [...group.modules],
            resolve,
            opts.requireConfig.shim,
        );
        const filePath = join(outDir, `${name}.js`);
        const mapPath = join(outDir, `${name}.js.map`);
        bundle.append(`//# sourceMappingURL=${name}.js.map`);
        await p(writeFile)(filePath, bundle);
        await p(writeFile)(
            mapPath,
            bundle.generateMap({
                file: `${name}.js`,
                includeContent: true,
            }),
        );
    }

    console.log('Wrote bundles');
}

type ModuleDetails = {
    source: string;
    id: string;
    plugins: string[];
};
const moduleDetailsCache = new Map<string, ModuleDetails>();
async function getModuleDetails(id: string, resolver: Resolver) {
    if (moduleDetailsCache.has(id)) {
        return moduleDetailsCache.get(id) as ModuleDetails;
    }

    const mod = parseModuleID(id);
    const path = resolver(mod.id);
    try {
        const source = await p(readFile)(path, 'utf8');
        const result = { source, ...mod };
        moduleDetailsCache.set(id, result);
        return result;
    } catch (err) {
        err.message = `Failed reading module "${id}" in ${path}`;
        throw err;
    }
}

const cache = new Map<string, string>();
async function generateBundleFile(
    modules: string[],
    resolver: Resolver,
    shim: RequireShim = {},
) {
    const shimmedModules = new Set(Object.keys(shim));
    const pendingModules = modules.map(async rawID => {
        if (cache.has(rawID)) {
            return [rawID, cache.get(rawID) as string] as [string, string];
        }

        let { source, id, plugins } = await getModuleDetails(rawID, resolver);

        if (plugins.includes('text')) {
            // TODO: Don't toString, properly handle sourcemap
            source = wrapTextModule(id, source).toString();
        } else {
            // TODO: detect then transform, rather than all the transformation
            // functions relying on each other
            source = shimmedModules.has(id)
                ? wrapShimmedModule(
                      id,
                      source,
                      // @ts-ignore
                      shim[id],
                  )
                : renameModule(id, source) || source;
        }

        cache.set(rawID, source);
        return [rawID, source] as [string, string];
    });
    const results = await Promise.all(pendingModules);

    return concatModules(new Map(results));
}

function parseModuleID(id: string) {
    const parts = id.split('!');
    return {
        id: parts[parts.length - 1],
        plugins: parts.slice(0, parts.length - 1),
    };
}

function concatModules(modules: Map<string, string>) {
    const bundle = new MagicBundle();
    bundle.prepend(
        `/* This file was generated by Bundlegento - ${Date()}  */\n\n`,
    );
    for (const [id, source] of modules) {
        bundle.addSource({
            filename: `../${id}.js`,
            content: new MagicString(source.toString()),
        });
    }
    return bundle;
}

const RE_DEFINE = /define\s*\(/;
export function renameModule(id: string, source: string): string | undefined {
    const match = RE_DEFINE.exec(source);
    if (!match) return wrapNonShimmedModule(id, source).toString();

    const defineIdx = match.index;

    let firstParenIdx = -1;
    let i = defineIdx + 'define'.length;

    while (true) {
        if (source[i] === '(') {
            firstParenIdx = i;
            const [, next = ''] = source.slice(i + 1).match(/\s*(.)/) || [];
            // Named module, bail
            if (/['"`]/.test(next)) return;
            break;
        }

        if (source[i] === ' ') {
            i++;
            continue;
        }

        return;
    }

    const strStart = source.slice(0, firstParenIdx + 1);
    const strEnd = source.slice(firstParenIdx + 1);

    return `${strStart}'${id}', ${strEnd}`;
}

export function wrapShimmedModule(
    id: string,
    source: string,
    shimConfig: RequireShim,
) {
    // For some reason, Magento core defines a shim
    // for a module that's a already an AMD module
    return isAMDWithDefine(source)
        ? renameModule(id, source)
        : wrapShimmedModuleTemp(id, source, shimConfig);
}
